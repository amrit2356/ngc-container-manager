#!/usr/bin/env bash
set -euo pipefail

# =============================================================================
# MLEnv - ML Environment Container Manager
# Version: 1.1.0
# =============================================================================

VERSION="1.1.0"

# -----------------------------
# Configuration
# -----------------------------
DEFAULT_IMAGE="nvcr.io/nvidia/pytorch:25.12-py3"
IMAGE="$DEFAULT_IMAGE"
REQUIREMENTS_PATH=""
FORCE_REQUIREMENTS=false
VERBOSE=false
WORKDIR="$(pwd)"
PROJECT_NAME="$(basename "$WORKDIR")"
# Use hash to prevent naming collisions across directories
WORKDIR_HASH="$(echo "$WORKDIR" | md5sum | cut -c1-8)"
CONTAINER_NAME="mlenv-${PROJECT_NAME}-${WORKDIR_HASH}"
LOG_DIR="$WORKDIR/.mlenv"
LOG_FILE="$LOG_DIR/mlenv.log"
REQUIREMENTS_MARKER="$LOG_DIR/.requirements_installed"

# mlenv Authentication
mlenv_CONFIG_DIR="$HOME/.mlenv"
mlenv_CONFIG_FILE="$mlenv_CONFIG_DIR/config"
mlenv_REGISTRY="nvcr.io"

# Port forwarding (comma-separated, e.g., "8888:8888,6006:6006")
PORTS=""
# Jupyter port (for jupyter command)
JUPYTER_PORT=""
# GPU devices (e.g., "0,1" or "all")
GPU_DEVICES="all"
# Environment file
ENV_FILE=""
# Resource limits
MEMORY_LIMIT=""
CPU_LIMIT=""
# User mapping (run as current user, not root)
RUN_AS_USER=true
# Custom command for exec
EXEC_CMD=""

mkdir -p "$LOG_DIR"

# -----------------------------
# Logging
# -----------------------------
log() {
  echo "$1" | tee -a "$LOG_FILE"
}

vlog() {
  local msg="[DEBUG] $(date '+%Y-%m-%d %H:%M:%S') - $1"
  if [ "$VERBOSE" = true ]; then
    echo "$msg" | tee -a "$LOG_FILE" >&2
  else
    echo "$msg" >> "$LOG_FILE"
  fi
}

success() {
  echo "✔ $1" | tee -a "$LOG_FILE"
}

info() {
  echo "ℹ $1" | tee -a "$LOG_FILE"
}

warn() {
  echo "⚠ $1" | tee -a "$LOG_FILE"
}

die() {
  echo "✖ $1" | tee -a "$LOG_FILE"
  exit 1
}

# -----------------------------
# mlenv Authentication
# -----------------------------
is_mlenv_authenticated() {
  # Check if docker is logged into nvcr.io
  if docker info 2>/dev/null | grep -q "Username.*nvcr.io" || \
     grep -q "nvcr.io" ~/.docker/config.json 2>/dev/null; then
    return 0
  fi
  
  # Also check our config file
  if [ -f "$mlenv_CONFIG_FILE" ]; then
    return 0
  fi
  
  return 1
}

check_mlenv_auth() {
  # Check if trying to use private image
  if [[ "$IMAGE" == *"nvcr.io"* ]] && [[ "$IMAGE" != *"/nvidia/"* ]]; then
    # Private image - require authentication
    if ! is_mlenv_authenticated; then
      error "Private mlenv image requires authentication"
      info "Run: mlenv login"
      return 1
    fi
  fi
  return 0
}

save_mlenv_credentials() {
  local api_key="$1"
  mkdir -p "$mlenv_CONFIG_DIR"
  chmod 700 "$mlenv_CONFIG_DIR"
  
  cat > "$mlenv_CONFIG_FILE" <<EOF
; NVIDIA mlenv CLI Configuration
[CURRENT]
apikey = $api_key
format_type = ascii
org = 

EOF
  chmod 600 "$mlenv_CONFIG_FILE"
  vlog "mlenv credentials saved to $mlenv_CONFIG_FILE"
}

# -----------------------------
# Preflight checks
# -----------------------------
check_docker() {
  if ! command -v docker >/dev/null 2>&1; then
    die "Docker is not installed. Install from https://docs.docker.com/get-docker/"
  fi
  if ! docker info >/dev/null 2>&1; then
    die "Docker daemon is not running. Start Docker and try again."
  fi
  vlog "Docker check passed"
}

check_gpu() {
  if ! docker info 2>/dev/null | grep -q "Runtimes:.*nvidia"; then
    die "NVIDIA Container Toolkit not detected. Install from https://github.com/NVIDIA/nvidia-container-toolkit"
  fi
  vlog "GPU runtime check passed"
}

check_requirements_file() {
  if [ -n "$REQUIREMENTS_PATH" ] && [ ! -f "$REQUIREMENTS_PATH" ]; then
    die "Requirements file not found: $REQUIREMENTS_PATH"
  fi
}

# -----------------------------
# Port detection
# -----------------------------
get_forwarded_ports() {
  # Get all forwarded ports for the container
  # Returns format: "host_port:container_port" one per line
  docker inspect "$CONTAINER_NAME" 2>/dev/null | \
    jq -r '.[0].NetworkSettings.Ports | to_entries[] | select(.value != null) | .key as $port | .value[] | "\(.HostPort):\($port | split("/")[0])"' 2>/dev/null || true
}

find_jupyter_port() {
  # Try to find a suitable port for Jupyter from forwarded ports
  # Priority: 8888, then 8889-8899, then first available in forwarded range
  local forwarded_ports
  forwarded_ports=$(get_forwarded_ports)
  
  if [ -z "$forwarded_ports" ]; then
    echo ""
    return 1
  fi
  
  # Check for 8888 first
  if echo "$forwarded_ports" | grep -q ":8888$"; then
    echo "8888"
    return 0
  fi
  
  # Check for 8889-8899
  for port in {8889..8899}; do
    if echo "$forwarded_ports" | grep -q ":${port}$"; then
      echo "$port"
      return 0
    fi
  done
  
  # Return first forwarded port in the range
  local first_port
  first_port=$(echo "$forwarded_ports" | grep -E ":[0-9]+$" | head -1 | cut -d: -f2)
  if [ -n "$first_port" ]; then
    echo "$first_port"
    return 0
  fi
  
  echo ""
  return 1
}

# -----------------------------
# Image operations
# -----------------------------
pull_image_if_needed() {
  # Check if image exists locally
  if docker image inspect "$IMAGE" >/dev/null 2>&1; then
    vlog "Image already available locally: $IMAGE"
    return 0
  fi
  
  log "▶ Pulling image: $IMAGE"
  info "This may take a few minutes on first run..."
  
  if docker pull "$IMAGE" 2>&1 | tee -a "$LOG_FILE"; then
    success "Image pulled successfully"
  else
    die "Failed to pull image: $IMAGE. Check credentials with: mlenv login"
  fi
}

# -----------------------------
# Container operations
# -----------------------------
container_exists() {
  docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"
}

container_running() {
  docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"
}

get_container_status() {
  if container_exists; then
    if container_running; then
      echo "running"
    else
      echo "stopped"
    fi
  else
    echo "absent"
  fi
}

# -----------------------------
# Create init script for user setup
# -----------------------------
create_init_script() {
  cat > "${LOG_DIR}/init.sh" <<'INIT_SCRIPT'
#!/bin/bash
# MLEnv container initialization script
# This runs as root to set up the user, then keeps container running

# Create group if doesn't exist
if ! getent group "${MLENV_GID}" >/dev/null 2>&1; then
  groupadd -g "${MLENV_GID}" "${MLENV_USER}" 2>/dev/null || true
fi

# Create user if doesn't exist
if ! id "${MLENV_UID}" >/dev/null 2>&1; then
  useradd -u "${MLENV_UID}" -g "${MLENV_GID}" -d "${MLENV_HOME}" -s /bin/bash "${MLENV_USER}" 2>/dev/null || true
fi

# Ensure home directory exists and has correct ownership
mkdir -p "${MLENV_HOME}" 2>/dev/null || true
chown "${MLENV_UID}:${MLENV_GID}" "${MLENV_HOME}" 2>/dev/null || true

# Keep container running
exec sleep infinity
INIT_SCRIPT
  
  chmod +x "${LOG_DIR}/init.sh"
  vlog "Created init script: ${LOG_DIR}/init.sh"
}

# -----------------------------
# Create devcontainer config for VS Code integration
# -----------------------------
create_devcontainer_config() {
  local devcontainer_dir="$WORKDIR/.devcontainer"
  local devcontainer_file="$devcontainer_dir/devcontainer.json"
  local backup_file="$LOG_DIR/devcontainer.json"
  
  # Create .devcontainer directory
  mkdir -p "$devcontainer_dir"
  
  # Generate devcontainer.json content
  local config_content
  config_content=$(cat <<'DEVCONTAINER_JSON'
{
    "name": "MLEnv GPU Container",
    "workspaceFolder": "/workspace",
    "remoteUser": "ubuntu",
    
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-python.python",
                "ms-toolsai.jupyter",
                "ms-python.vscode-pylance",
                "ms-python.debugpy",
                "charliermarsh.ruff"
            ],
            "settings": {
                "python.defaultInterpreterPath": "/usr/bin/python3",
                "python.terminal.activateEnvironment": false,
                "terminal.integrated.defaultProfile.linux": "bash",
                "terminal.integrated.cwd": "/workspace",
                "files.watcherExclude": {
                    "**/.git/objects/**": true,
                    "**/.git/subtree-cache/**": true,
                    "**/node_modules/*/**": true,
                    "**/.hg/store/**": true,
                    "**/__pycache__/**": true,
                    "**/.mlenv/**": true
                },
                "jupyter.jupyterServerType": "local"
            }
        }
    },
    
    "forwardPorts": [8888, 6006],
    "portsAttributes": {
        "8888": {
            "label": "Jupyter Lab",
            "onAutoForward": "notify"
        },
        "6006": {
            "label": "TensorBoard",
            "onAutoForward": "silent"
        }
    }
}
DEVCONTAINER_JSON
)
  
  # Write to .devcontainer/ (where VS Code expects it)
  echo "$config_content" > "$devcontainer_file"
  
  # Also backup to .mlenv/
  echo "$config_content" > "$backup_file"
  
  vlog "Created devcontainer config: $devcontainer_file"
}

# -----------------------------
# Build docker run arguments
# -----------------------------
build_docker_args() {
  local args=()
  
  # Base configuration
  args+=("--name" "$CONTAINER_NAME")
  args+=("-d")
  args+=("--restart" "unless-stopped")
  
  # GPU configuration
  if [ "$GPU_DEVICES" = "all" ]; then
    args+=("--gpus" "all")
  else
    args+=("--gpus" "device=${GPU_DEVICES}")
  fi
  
  # Memory and performance
  args+=("--shm-size=16g")
  args+=("--ulimit" "memlock=-1")
  args+=("--ulimit" "stack=67108864")
  
  # Resource limits
  if [ -n "$MEMORY_LIMIT" ]; then
    args+=("--memory" "$MEMORY_LIMIT")
    vlog "Memory limit: $MEMORY_LIMIT"
  fi
  if [ -n "$CPU_LIMIT" ]; then
    args+=("--cpus" "$CPU_LIMIT")
    vlog "CPU limit: $CPU_LIMIT"
  fi
  
  # Port forwarding
  if [ -n "$PORTS" ]; then
    IFS=',' read -ra PORT_ARRAY <<< "$PORTS"
    for port in "${PORT_ARRAY[@]}"; do
      args+=("-p" "$port")
      vlog "Forwarding port: $port"
    done
  fi
  
  # Environment file
  if [ -n "$ENV_FILE" ]; then
    if [ -f "$ENV_FILE" ]; then
      args+=("--env-file" "$ENV_FILE")
      vlog "Using env file: $ENV_FILE"
    else
      warn "Environment file not found: $ENV_FILE"
    fi
  fi
  
  # Dev Container labels (for VS Code integration)
  args+=("--label" "devcontainer.local_folder=$WORKDIR")
  args+=("--label" "com.microsoft.devcontainers.workspaceFolder=/workspace")
  args+=("--label" "devcontainer.config_file=$WORKDIR/.devcontainer/devcontainer.json")
  vlog "Added Dev Container labels for VS Code integration"
  
  # User mapping (avoid running as root)
  if [ "$RUN_AS_USER" = true ]; then
    local USER_NAME="${USER:-mlenv-user}"
    local USER_UID="$(id -u)"
    local USER_GID="$(id -g)"
    local USER_HOME="/home/${USER_NAME}"
    
    # Pass user info as environment variables
    args+=("-e" "MLENV_USER=${USER_NAME}")
    args+=("-e" "MLENV_UID=${USER_UID}")
    args+=("-e" "MLENV_GID=${USER_GID}")
    args+=("-e" "MLENV_HOME=${USER_HOME}")
    
    # NOTE: Do NOT set --user here - init script needs root to create user
    # We'll exec into the container as the user later
    vlog "Will create user: ${USER_UID}:${USER_GID} (${USER_NAME})"
    
    # Mount init script
    args+=("-v" "${LOG_DIR}/init.sh:/mlenv-init.sh:ro")
    args+=("--entrypoint" "/bin/bash")
  fi
  
  # Volume mount
  args+=("-v" "$WORKDIR:/workspace")
  args+=("-w" "/workspace")
  
  # Image
  args+=("$IMAGE")
  
  # Command
  if [ "$RUN_AS_USER" = true ]; then
    args+=("-c" "/mlenv-init.sh")
  else
    args+=("sleep" "infinity")
  fi
  
  printf '%s\n' "${args[@]}"
}

# -----------------------------
# Install requirements
# -----------------------------
install_requirements() {
  if [ -z "$REQUIREMENTS_PATH" ]; then
    return 0
  fi
  
  local rel_path
  rel_path="$(realpath --relative-to="$WORKDIR" "$REQUIREMENTS_PATH")"
  
  # Check if already installed (unless force flag is set)
  if [ "$FORCE_REQUIREMENTS" = false ] && [ -f "$REQUIREMENTS_MARKER" ]; then
    local marker_content
    marker_content="$(cat "$REQUIREMENTS_MARKER")"
    local current_hash
    current_hash="$(md5sum "$REQUIREMENTS_PATH" | cut -d' ' -f1)"
    
    if [ "$marker_content" = "$current_hash" ]; then
      info "Requirements already installed (use --force-requirements to reinstall)"
      return 0
    fi
  fi
  
  log "▶ Installing requirements from: $rel_path"
  
  # Run pip as the user, not root
  if [ "$RUN_AS_USER" = true ]; then
    local user_uid="$(id -u)"
    if docker exec --user "${user_uid}" "$CONTAINER_NAME" bash -c \
      "pip install --no-cache-dir --upgrade pip && pip install --no-cache-dir -r '/workspace/$rel_path'" >> "$LOG_FILE" 2>&1; then
      md5sum "$REQUIREMENTS_PATH" | cut -d' ' -f1 > "$REQUIREMENTS_MARKER"
      success "Requirements installed"
    else
      die "Failed to install requirements. Check logs: mlenv logs"
    fi
  else
    if docker exec "$CONTAINER_NAME" bash -c \
      "pip install --no-cache-dir --upgrade pip && pip install --no-cache-dir -r '/workspace/$rel_path'" >> "$LOG_FILE" 2>&1; then
      md5sum "$REQUIREMENTS_PATH" | cut -d' ' -f1 > "$REQUIREMENTS_MARKER"
      success "Requirements installed"
    else
      die "Failed to install requirements. Check logs: mlenv logs"
    fi
  fi
}

# -----------------------------
# Commands
# -----------------------------
cmd_up() {
  check_docker
  check_gpu
  check_requirements_file
  
  # Check mlenv authentication if needed
  if ! check_mlenv_auth; then
    die "mlenv authentication required for private images"
  fi
  
  vlog "Configuration:"
  vlog "  Image: $IMAGE"
  vlog "  Container: $CONTAINER_NAME"
  vlog "  Workdir: $WORKDIR"
  vlog "  GPUs: $GPU_DEVICES"
  
  local status
  status="$(get_container_status)"
  
  case "$status" in
    running)
      info "Container already running"
      ;;
    stopped)
      log "▶ Starting existing container"
      docker start "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
      success "Container started"
      ;;
    absent)
      # Pull image if needed before creating container
      pull_image_if_needed
      
      # Create init script if running as user
      if [ "$RUN_AS_USER" = true ]; then
        create_init_script
      fi
      
      # Create devcontainer config for VS Code
      create_devcontainer_config
      
      log "▶ Creating container: $CONTAINER_NAME"
      
      # Build args array and run directly (no eval needed)
      readarray -t docker_args < <(build_docker_args)
      
      if docker run "${docker_args[@]}" >> "$LOG_FILE" 2>&1; then
        success "Container created and started"
      else
        die "Failed to create container. Check logs: mlenv logs"
      fi
      ;;
  esac
  
  # Wait for container to be ready
  sleep 1
  
  # Install requirements if specified
  install_requirements
  
  success "Environment ready"
  if [ -n "$PORTS" ]; then
    info "Ports forwarded: $PORTS"
  fi
  info "Enter with: mlenv exec"
}

cmd_exec() {
  check_docker
  
  if ! container_running; then
    die "Container not running. Start with: mlenv up"
  fi
  
  # Determine user for exec
  local exec_user=""
  if [ "$RUN_AS_USER" = true ]; then
    exec_user="--user $(id -u):$(id -g)"
  fi
  
  if [ -n "$EXEC_CMD" ]; then
    # Execute specific command
    vlog "Executing command: $EXEC_CMD"
    docker exec -it $exec_user "$CONTAINER_NAME" bash -c "$EXEC_CMD"
  else
    # Interactive bash
    docker exec -it $exec_user "$CONTAINER_NAME" bash
  fi
}

cmd_down() {
  check_docker
  
  if container_running; then
    log "■ Stopping container"
    docker stop "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
    success "Container stopped"
  else
    info "Container not running"
  fi
}

cmd_rm() {
  check_docker
  
  if container_exists; then
    log "✖ Removing container (your code on host is safe)"
    docker rm -f "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
    
    # Clean up markers and init script
    rm -f "$REQUIREMENTS_MARKER"
    rm -f "${LOG_DIR}/init.sh"
    
    success "Container removed"
  else
    info "Container does not exist"
  fi
}

cmd_restart() {
  cmd_down
  sleep 1
  cmd_up
}

cmd_logs() {
  if [ -f "$LOG_FILE" ]; then
    cat "$LOG_FILE"
  else
    info "No logs found"
  fi
}

cmd_status() {
  local status
  status="$(get_container_status)"
  
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "Container: $CONTAINER_NAME"
  echo "Status: $status"
  echo "Workdir: $WORKDIR"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  
  if container_exists; then
    echo ""
    docker ps -a --filter "name=${CONTAINER_NAME}" --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
    
    if container_running; then
      echo ""
      echo "GPU Status:"
      docker exec "$CONTAINER_NAME" nvidia-smi --query-gpu=index,name,utilization.gpu,memory.used,memory.total --format=csv 2>/dev/null || echo "  Unable to query GPUs"
      
      echo ""
      echo "Forwarded Ports:"
      local ports
      ports=$(get_forwarded_ports)
      if [ -n "$ports" ]; then
        echo "$ports" | while IFS=: read -r host_port container_port; do
          echo "  localhost:${host_port} → container:${container_port}"
        done
      else
        echo "  No ports forwarded"
      fi
    fi
  fi
}

cmd_list() {
  info "MLEnv Containers Across All Projects"
  echo ""
  
  local containers
  containers=$(docker ps -a --filter "name=mlenv-" --format "{{.Names}}" 2>/dev/null || true)
  
  if [ -z "$containers" ]; then
    info "No MLEnv containers found"
    return 0
  fi
  
  # Header
  printf "%-40s %-15s %-20s\n" "CONTAINER" "STATUS" "IMAGE"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  
  # List containers
  docker ps -a --filter "name=mlenv-" --format "{{.Names}}\t{{.Status}}\t{{.Image}}" | while IFS=$'\t' read -r name status image; do
    # Truncate long names/images
    name_short="${name:0:39}"
    image_short="${image:0:19}"
    status_short="${status:0:14}"
    
    printf "%-40s %-15s %-20s\n" "$name_short" "$status_short" "$image_short"
  done
  
  echo ""
  local total
  total=$(echo "$containers" | wc -l)
  info "Total: $total containers"
  echo ""
  info "Tip: Use 'mlenv clean --containers' to remove stopped containers"
}

cmd_jupyter() {
  check_docker
  check_gpu
  
  # Determine which port to use (default to 8888 if not specified)
  local container_port="${JUPYTER_PORT:-8888}"
  local default_ports="${container_port}:${container_port}"
  local host_port=""
  
  # Check container status
  local status
  status="$(get_container_status)"
  
  case "$status" in
    absent)
      # Container doesn't exist - create it with port forwarding
      log "▶ Container not found. Creating with Jupyter port forwarding..."
      
      # Auto-detect requirements.txt if it exists and wasn't specified
      if [ -z "$REQUIREMENTS_PATH" ] && [ -f "$WORKDIR/requirements.txt" ]; then
        REQUIREMENTS_PATH="$WORKDIR/requirements.txt"
        info "Auto-detected requirements.txt"
      fi
      
      # Set default port forwarding if not already set
      if [ -z "$PORTS" ]; then
        PORTS="$default_ports"
        info "Using default port forwarding: $PORTS"
      fi
      
      # Create and start the container
      cmd_up
      ;;
      
    stopped|running)
      # Container exists - check if it has proper port forwarding
      vlog "Checking port forwarding on existing container..."
      
      # Check if the container has the required port forwarding
      local has_port=false
      local existing_ports
      existing_ports=$(docker inspect "$CONTAINER_NAME" 2>/dev/null | \
        jq -r '.[0].NetworkSettings.Ports | to_entries[] | select(.value != null) | .key' 2>/dev/null || true)
      
      if [ -n "$existing_ports" ]; then
        # Check if our target port is in there
        if echo "$existing_ports" | grep -q "^${container_port}/tcp$"; then
          has_port=true
        fi
      fi
      
      if [ "$has_port" = false ]; then
        # Container exists but doesn't have the required port
        echo ""
        warn "Container exists but port $container_port is not forwarded"
        info "Docker doesn't allow adding ports to existing containers"
        info "Recreating container with port forwarding: $default_ports"
        echo ""
        
        # Auto-detect requirements.txt if it exists and wasn't specified
        if [ -z "$REQUIREMENTS_PATH" ] && [ -f "$WORKDIR/requirements.txt" ]; then
          REQUIREMENTS_PATH="$WORKDIR/requirements.txt"
          info "Auto-detected requirements.txt for recreation"
        fi
        
        # Remove the old container
        log "▶ Removing old container..."
        cmd_rm
        
        # Set port forwarding for recreation
        if [ -z "$PORTS" ]; then
          PORTS="$default_ports"
        fi
        
        # Recreate with port forwarding
        log "▶ Creating new container with port forwarding..."
        cmd_up
      else
        # Port is forwarded, just ensure container is running
        if [ "$status" = "stopped" ]; then
          log "▶ Starting existing container"
          docker start "$CONTAINER_NAME" >> "$LOG_FILE" 2>&1
          success "Container started"
          sleep 1
        else
          vlog "Container already running with proper port forwarding"
        fi
      fi
      ;;
  esac
  
  # Now container is running with proper ports - find the host port
  if [ -z "$JUPYTER_PORT" ]; then
    # Try to auto-detect a suitable port from forwarded ports
    container_port=$(find_jupyter_port)
    
    if [ -z "$container_port" ]; then
      # This shouldn't happen after our setup above, but just in case
      die "Failed to detect Jupyter port after container setup"
    fi
    
    vlog "Auto-detected container port: $container_port"
  fi
  
  # Find the corresponding host port
  host_port=$(get_forwarded_ports | grep ":${container_port}$" | cut -d: -f1 | head -1)
  
  if [ -z "$host_port" ]; then
    # This also shouldn't happen after our setup
    die "Failed to detect host port mapping after container setup"
  fi
  
  log "▶ Starting Jupyter Lab on container port $container_port"
  
  # Show access info
  echo ""
  success "Jupyter will be accessible at: http://localhost:$host_port"
  info "Token will be shown below..."
  echo ""
  
  # Run as user if user mapping is enabled
  local exec_user=""
  if [ "$RUN_AS_USER" = true ]; then
    exec_user="--user $(id -u):$(id -g)"
  fi
  
  docker exec -it $exec_user "$CONTAINER_NAME" bash -c "jupyter lab --ip=0.0.0.0 --port=$container_port --no-browser --allow-root"
}

cmd_clean() {
  local clean_logs=false
  local clean_containers=false
  local clean_images=false
  
  # Parse clean options
  if [ $# -eq 0 ]; then
    # Default: just logs
    clean_logs=true
  else
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --logs)
          clean_logs=true
          shift
          ;;
        --containers)
          clean_containers=true
          shift
          ;;
        --images)
          clean_images=true
          shift
          ;;
        --all)
          clean_logs=true
          clean_containers=true
          clean_images=true
          shift
          ;;
        *)
          shift
          ;;
      esac
    done
  fi
  
  log "▶ Cleaning MLEnv artifacts"
  echo ""
  
  # Clean logs
  if [ "$clean_logs" = true ]; then
    if [ -d "$LOG_DIR" ]; then
      rm -rf "$LOG_DIR"
      success "Cleaned logs: $LOG_DIR"
    else
      info "No logs to clean"
    fi
  fi
  
  # Clean old containers
  if [ "$clean_containers" = true ]; then
    echo ""
    info "Searching for stopped MLEnv containers..."
    local stopped_containers
    stopped_containers=$(docker ps -a --filter "name=mlenv-" --filter "status=exited" --format "{{.Names}}" 2>/dev/null || true)
    
    if [ -n "$stopped_containers" ]; then
      echo ""
      echo "Stopped containers found:"
      echo "$stopped_containers" | while read -r container; do
        echo "  - $container"
      done
      echo ""
      read -p "Remove these containers? [y/N] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "$stopped_containers" | while read -r container; do
          docker rm "$container" >/dev/null 2>&1
          success "Removed: $container"
        done
      else
        info "Skipped container cleanup"
      fi
    else
      info "No stopped MLEnv containers found"
    fi
  fi
  
  # Clean dangling images
  if [ "$clean_images" = true ]; then
    echo ""
    read -p "Remove dangling Docker images? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      docker image prune -f
      success "Cleaned dangling images"
    else
      info "Skipped image cleanup"
    fi
  fi
  
  echo ""
  success "Cleanup complete"
}

cmd_version() {
  echo "MLEnv - ML Environment Manager v${VERSION}"
  echo "Copyright (c) 2025"
  echo ""
  echo "Check for updates: https://github.com/your-username/mlenv"
}

cmd_login() {
  log "▶ mlenv Authentication Setup"
  echo ""
  
  info "NVIDIA mlenv allows you to access private container images and models"
  info "You'll need an mlenv API key from: https://mlenv.nvidia.com/setup/api-key"
  echo ""
  
  # Prompt for API key
  read -p "Enter your mlenv API Key: " -s api_key
  echo ""
  
  if [ -z "$api_key" ]; then
    die "API key cannot be empty"
  fi
  
  log "▶ Logging into $mlenv_REGISTRY..."
  
  # Login to Docker registry
  if echo "$api_key" | docker login "$mlenv_REGISTRY" --username '$oauthtoken' --password-stdin >> "$LOG_FILE" 2>&1; then
    success "Successfully logged into $mlenv_REGISTRY"
    
    # Save credentials to mlenv config
    save_mlenv_credentials "$api_key"
    
    echo ""
    success "mlenv authentication complete!"
    info "You can now pull private images from $mlenv_REGISTRY"
    echo ""
    info "Example: mlenv up --image nvcr.io/your-org/your-image:tag"
  else
    die "Login failed. Please check your API key and try again."
  fi
}

cmd_logout() {
  log "▶ Logging out of mlenv"
  
  # Logout from Docker registry
  if docker logout "$mlenv_REGISTRY" >> "$LOG_FILE" 2>&1; then
    success "Logged out of $mlenv_REGISTRY"
  fi
  
  # Remove saved credentials
  if [ -f "$mlenv_CONFIG_FILE" ]; then
    rm -f "$mlenv_CONFIG_FILE"
    success "Removed mlenv credentials"
  fi
  
  echo ""
  info "You'll need to run 'mlenv login' again to access private images"
}

cmd_help() {
  cat <<EOF
MLEnv - ML Environment Manager - GPU Development Environment

USAGE:
  mlenv <command> [options]

COMMANDS:
  login       Authenticate with mlenv for private images
  logout      Remove mlenv authentication
  up          Create/start container
  exec        Open interactive shell (or run command with -c)
  down        Stop container
  restart     Restart container
  rm          Remove container (keeps your code safe)
  status      Show container status and GPU info
  list        List all MLEnv containers across projects
  jupyter     Start Jupyter Lab
  logs        View debug logs
  clean       Remove MLEnv artifacts
  version     Show version information
  help        Show this help

OPTIONS (for 'up' command):
  --image <name>              Docker image (default: $DEFAULT_IMAGE)
  --requirements <path>       Install Python requirements from file
  --force-requirements        Force reinstall requirements
  --port <mapping>            Port forwarding (e.g., "8888:8888,6006:6006")
  --gpu <devices>             GPU devices (e.g., "0,1" or "all", default: all)
  --env-file <path>           Environment variables file
  --memory <limit>            Memory limit (e.g., "16g")
  --cpus <limit>              CPU limit (e.g., "4.0")
  --no-user-mapping           Run as root instead of current user
  --verbose                   Enable verbose output

OPTIONS (for 'exec' command):
  -c <command>                Execute command instead of interactive shell

OPTIONS (for 'jupyter' command):
  --port <port>               Port to run Jupyter on (default: auto-detect)

EXAMPLES:
  # First time setup - authenticate with mlenv
  mlenv login

  # Basic setup
  mlenv up
  mlenv exec

  # Full setup with Jupyter (auto-detects port 8888)
  mlenv up --requirements requirements.txt --port 8888:8888,6006:6006
  mlenv jupyter

  # Jupyter on custom port (auto-detects port 8889)
  mlenv up --port 8889:8889
  mlenv jupyter
  # Access at: http://localhost:8889

  # Multiple Jupyter instances on same container
  mlenv up --port 8888:8888,8889:8889,8890:8890
  mlenv jupyter --port 8888    # Terminal 1 → http://localhost:8888
  mlenv jupyter --port 8889    # Terminal 2 → http://localhost:8889
  mlenv jupyter --port 8890    # Terminal 3 → http://localhost:8890

  # Use private mlenv image
  mlenv up --image nvcr.io/your-org/your-private-image:latest

  # Run specific command
  mlenv exec -c "python train.py --epochs 10"

  # Use specific GPUs
  mlenv up --gpu 0,1

  # Development workflow
  mlenv up --env-file .env --port 8888:8888
  mlenv exec
  # ... do work ...
  mlenv down

  # Clean old containers
  mlenv clean --containers

  # Full cleanup
  mlenv clean --all

  # Clean restart
  mlenv rm
  mlenv up --force-requirements

CLEAN OPTIONS:
  --logs              Remove log files (default)
  --containers        Remove stopped MLEnv containers
  --images            Remove dangling Docker images
  --all               Clean everything

PORT FORWARDING NOTES:
  • Port forwarding must be set during container creation (mlenv up --port)
  • Format: "host_port:container_port" (e.g., "8888:8888" or "9000:8888")
  • mlenv jupyter automatically detects forwarded ports and uses them
  • Priority order: 8888 → 8889-8899 → first available forwarded port
  • For multiple Jupyter instances, forward multiple ports:
    mlenv up --port 8888:8888,8889:8889,8890:8890
  • Use --port with jupyter command to override auto-detection:
    mlenv jupyter --port 8889
  • Check current forwarding with: mlenv status

NOTES:
  • Your code stays on the host (bind-mounted to /workspace)
  • Container name includes directory hash to prevent collisions
  • Requirements are cached (reinstalled only if file changes)
  • Logs stored in: $LOG_DIR/mlenv.log
  • Container auto-restarts unless explicitly stopped

EOF
}

# -----------------------------
# Main
# -----------------------------
command="${1:-help}"
shift || true

# Special handling for clean command - save its options
clean_args=()
if [ "$command" = "clean" ]; then
  clean_args=("$@")
  # Don't parse these as global options
  set --
fi

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    --image)
      IMAGE="$2"
      shift 2
      ;;
    --requirements)
      REQUIREMENTS_PATH="$2"
      shift 2
      ;;
    --force-requirements)
      FORCE_REQUIREMENTS=true
      shift
      ;;
    --port)
      # Handle both --port for 'up' and 'jupyter' commands
      if [ "$command" = "jupyter" ]; then
        JUPYTER_PORT="$2"
      else
        PORTS="$2"
      fi
      shift 2
      ;;
    --gpu)
      GPU_DEVICES="$2"
      shift 2
      ;;
    --env-file)
      ENV_FILE="$2"
      shift 2
      ;;
    --memory)
      MEMORY_LIMIT="$2"
      shift 2
      ;;
    --cpus)
      CPU_LIMIT="$2"
      shift 2
      ;;
    --no-user-mapping)
      RUN_AS_USER=false
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    -c)
      EXEC_CMD="$2"
      shift 2
      ;;
    *)
      die "Unknown option: $1. Use 'mlenv help' for usage."
      ;;
  esac
done

# Execute command
case "$command" in
  login)    cmd_login ;;
  logout)   cmd_logout ;;
  up)       cmd_up ;;
  exec)     cmd_exec ;;
  down)     cmd_down ;;
  restart)  cmd_restart ;;
  rm)       cmd_rm ;;
  logs)     cmd_logs ;;
  status)   cmd_status ;;
  list)     cmd_list ;;
  jupyter)  cmd_jupyter ;;
  clean)    cmd_clean "${clean_args[@]}" ;;
  version|--version|-v)  cmd_version ;;
  help|--help|-h)  cmd_help ;;
  *)
    die "Unknown command: $command. Use 'mlenv help' for usage."
    ;;
esac